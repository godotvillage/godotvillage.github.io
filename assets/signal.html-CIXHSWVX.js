import{_ as a,c as n,a as s,e as t,o as l}from"./app-oSfmv__P.js";const e={};function h(p,i){return l(),n("div",null,[i[0]||(i[0]=s('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>在开发游戏的过程中，往往会出现这样的情况：</p><ul><li>玩家受到伤害，需要让血量条发生变化</li><li>动画播放结束了，需要用代码控制播放下一个动画</li><li>要设置机关，当玩家触碰后激活某处机关</li></ul><p>我们可能会有以下思路：</p><ul><li>先获得到需要触发变化的节点，然后调用节点上的函数，例如第一种情况在玩家脚本中：<code>get_node(&quot;hp_bar&quot;).update_value(hp_value)</code></li><li>先通知父级节点，然后再想办法通知到对应的节点处理，例如第一种情况在玩家脚本中：<code>get_parent().do_something(hp_value)</code></li><li>先把自己存放再需要变化的节点的属性里，然后每帧根据玩家的属性，例如第一种情况在玩家脚本中：<code>hp_bar.player = self</code>，然后在血量的process函数中<code>update_value(player.hp_value)</code></li></ul><p>很容易发现以上代码中，传输数据是一件很不方便的事情。尤其是我们不可能将所有代码全部放在一个庞大的<code>game.tscn</code>场景文件中，这使得节点之间的交互更是一件复杂的事情。</p><p>那有什么办法可以简化这种操作呢？或者说，如何将一个事件，和处理这个事件的函数解绑呢？</p><p>答案是<strong>信号</strong><code>signal</code>。</p>',8)),t(" more "),i[1]||(i[1]=s(`<div class="hint-container info"><p class="hint-container-title">信号机制</p><p>在别的语境里，信号通常是事件监听、事件委托、观察者模式、订阅者模式等名词。<br> 在代码中可以声明一个事件，然后将需要处理事件的行为维护成一个数组。当发生这个事件时，就会遍历调用这些行为函数。（观察者模式）<br> 或者在一个第三方的位置，设置一个事件。事件可以由事件发布者发布，再由中介者发布给所有的订阅者。（订阅者模式）<br> 而这些，在Godot中就被封装成了信号系统。</p></div><h2 id="godot中的信号" tabindex="-1"><a class="header-anchor" href="#godot中的信号"><span>Godot中的信号</span></a></h2><p>Godot中的信号是一种常量。类型是Signal。我们并不需要关心他的值是什么。只需要了解信号的几个重要的函数。</p><p>可以用以下方式方便的定义信号。</p><div class="language-gdscript line-numbers-mode" data-highlighter="shiki" data-ext="gdscript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-gdscript"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 定义一个叫some_sig的信号</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">signal</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> some_sig</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 定义一个带有两个参数的信号</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">signal</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> other_sig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#ABB2BF;--shiki-dark-font-style:italic;">param_a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#ABB2BF;--shiki-dark-font-style:italic;">param_b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>绑定信号的方法也很简单，只需要让信号链接到一个Callable类型的变量上：</p><div class="language-gdscript line-numbers-mode" data-highlighter="shiki" data-ext="gdscript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-gdscript"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 将some_sig信号链接到一个名为_handle_func的函数上。</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">some_sig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">connect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">_handle_func</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 将other_sig信号链接到一个名为_handle_func_with_params的有参数的函数上。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 因为信号和函数的参数一致，所以无需特殊处理</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">other_sig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">connect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">_handle_func_with_params</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 将some_sig信号链接到_handle_func_with_params并传入参数。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 由于some_sig无法提供_handle_func_with_params需要的两个参数，</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 所以使用bind为_handle_func_with_params绑定两个固定的参数生成一个新的Callable。</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">some_sig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">connect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">_handle_func_with_params</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">bind</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;来自some_sig的固定参数&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">func</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> _handle_func</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">():</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;触发无参数函数&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">func</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> _handle_func_with_params</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#ABB2BF;--shiki-dark-font-style:italic;">param_a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#ABB2BF;--shiki-dark-font-style:italic;">param_b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">):</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;触发有参数函数: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%d</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> %s</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> %</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">param_a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">param_b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">Callable与bind</p><p><strong>Callable</strong><br><code>Callable</code>是一种变量类型，指的是可以被调用的函数。使用<code>func</code>关键字声明的具名函数和匿名函数都是<code>Callable</code>类型的变量。<br> 例如上文中的：</p><div class="language-gdscript line-numbers-mode" data-highlighter="shiki" data-ext="gdscript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-gdscript"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">func</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> _handle_func_with_params</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#ABB2BF;--shiki-dark-font-style:italic;">param_a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#ABB2BF;--shiki-dark-font-style:italic;">param_b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">):</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;触发有参数函数: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%d</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> %s</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> %</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">param_a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">param_b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>_handle_func_with_params</code>就是一个<code>Callable</code>类型。</p><p>信号可以与<code>Callable</code>类型链接。所以在<code>Signal.connect</code>函数中传入类似<code>_handle_func_with_params</code>的函数名即可。</p><p><strong>bind</strong><br> bind可以返回一个函数的副本，并为其绑定一个或多个固定的参数。<br> 例如上文中的：</p><div class="language-gdscript line-numbers-mode" data-highlighter="shiki" data-ext="gdscript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-gdscript"><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">_handle_func_with_params</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">bind</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;来自some_sig的固定参数&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>是调用了<code>_handle_func_with_params</code>这个<code>Callable</code>变量上的<code>bind</code>方法。返回了一个新的<code>Callable</code>类型的变量。<strong>这个变量和原来的函数不是一个值。</strong></p></div>`,8))])}const d=a(e,[["render",h]]),r=JSON.parse('{"path":"/tutorial/signal.html","title":"信号系统","lang":"zh-CN","frontmatter":{"title":"信号系统","author":"Moshangzhu","date":"2025-10-17T00:00:00.000Z","category":["教程"],"tag":["信号"],"description":"简介 在开发游戏的过程中，往往会出现这样的情况： 玩家受到伤害，需要让血量条发生变化 动画播放结束了，需要用代码控制播放下一个动画 要设置机关，当玩家触碰后激活某处机关 我们可能会有以下思路： 先获得到需要触发变化的节点，然后调用节点上的函数，例如第一种情况在玩家脚本中：get_node(\\"hp_bar\\").update_value(hp_value)...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"信号系统\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-10-17T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-17T12:09:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Moshangzhu\\"}]}"],["meta",{"property":"og:url","content":"https://godotvillage.github.io/tutorial/signal.html"}],["meta",{"property":"og:site_name","content":"Godot新手村"}],["meta",{"property":"og:title","content":"信号系统"}],["meta",{"property":"og:description","content":"简介 在开发游戏的过程中，往往会出现这样的情况： 玩家受到伤害，需要让血量条发生变化 动画播放结束了，需要用代码控制播放下一个动画 要设置机关，当玩家触碰后激活某处机关 我们可能会有以下思路： 先获得到需要触发变化的节点，然后调用节点上的函数，例如第一种情况在玩家脚本中：get_node(\\"hp_bar\\").update_value(hp_value)..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-17T12:09:12.000Z"}],["meta",{"property":"article:author","content":"Moshangzhu"}],["meta",{"property":"article:tag","content":"信号"}],["meta",{"property":"article:published_time","content":"2025-10-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-17T12:09:12.000Z"}]]},"git":{"createdTime":1760702952000,"updatedTime":1760702952000,"contributors":[{"name":"moshangzhu","username":"moshangzhu","email":"925236118@qq.com","commits":1,"url":"https://github.com/moshangzhu"}]},"readingTime":{"minutes":3.27,"words":982},"filePathRelative":"tutorial/signal.md","excerpt":"<h2>简介</h2>\\n<p>在开发游戏的过程中，往往会出现这样的情况：</p>\\n<ul>\\n<li>玩家受到伤害，需要让血量条发生变化</li>\\n<li>动画播放结束了，需要用代码控制播放下一个动画</li>\\n<li>要设置机关，当玩家触碰后激活某处机关</li>\\n</ul>\\n<p>我们可能会有以下思路：</p>\\n<ul>\\n<li>先获得到需要触发变化的节点，然后调用节点上的函数，例如第一种情况在玩家脚本中：<code>get_node(\\"hp_bar\\").update_value(hp_value)</code></li>\\n<li>先通知父级节点，然后再想办法通知到对应的节点处理，例如第一种情况在玩家脚本中：<code>get_parent().do_something(hp_value)</code></li>\\n<li>先把自己存放再需要变化的节点的属性里，然后每帧根据玩家的属性，例如第一种情况在玩家脚本中：<code>hp_bar.player = self</code>，然后在血量的process函数中<code>update_value(player.hp_value)</code></li>\\n</ul>\\n<p>很容易发现以上代码中，传输数据是一件很不方便的事情。尤其是我们不可能将所有代码全部放在一个庞大的<code>game.tscn</code>场景文件中，这使得节点之间的交互更是一件复杂的事情。</p>\\n<p>那有什么办法可以简化这种操作呢？或者说，如何将一个事件，和处理这个事件的函数解绑呢？</p>\\n<p>答案是<strong>信号</strong><code>signal</code>。</p>\\n","autoDesc":true}');export{d as comp,r as data};
